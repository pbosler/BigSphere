Code associated with

P. Bosler, L. Wang, R. Krasny, and C. Jablonowski, 2014. \char`\"{}\+A Lagrangian particle/panel method for the barotropic vorticity equation on a rotating sphere,\char`\"{} Fluid Dynamics Research, 46 \+: 031406.

Bosler, P. A., \char`\"{}\+Particle Methods for Geophysical Flow on the Sphere,\char`\"{} Ph\+D Thesis, University of Michigan, 2013.

This software provides a Lagrangian Particle-\/\+Panel Method for solving the barotropic vorticity equation and the advection equation on the sphere and in the plane.

A shallow water equation solver is in development.

\section*{Design / Use }

Although it is written in modern Fortran rather than C++, the code is organized in an object-\/oriented style. This means that for each task the code performs, there is a derived data type that corresponds to that task (like a C++ class). Each module file contains one derived data type and its associated methods. For example, \hyperlink{PlaneMesh_8f90}{Plane\+Mesh.\+f90} contains the data type for moving meshes in the plane and interfaces to all the functions that are implemented on Plane\+Mesh objects. The \hyperlink{PlaneDirectSum_8f90}{Plane\+Direct\+Sum.\+f90} module defines the Runge-\/\+Kutta time stepping data type for plane meshes, and contains all of the timestepping functions.

Each object must be created in memory using its New method, many objects must then be initialized using a call to an Init or Initialize subroutine. For clean code, every time a New subroutine is called on an object, a corresponding call to that object's Delete subroutine should be used when the object is no longer needed or goes out of scope.

\subsection*{Example\+: }

To define a Rossby-\/\+Haurwitz wave vorticity distribution for a sphere mesh, a user would first allocate the Vorticity\+Setup object by calling its New subroutine. Then the wave would be initialized with user-\/defined parameters (most commonly read from a namelist file) by calling the Vorticity\+Setup module's Init\+R\+H\+Wave routine. Finally, the wave is defined and users can define the vorticity on a sphere mesh by calling the Set\+R\+H\+Wave\+On\+Mesh subroutine. \begin{DoxyVerb}call New(rhWave, nIntegers, nReals)
call InitRH4Wave(rhWave, backgoundWindSpeed, amplitude)
call SetRH4WaveOnMesh( sphere, rhWave)
\end{DoxyVerb}


Code runs... \begin{DoxyVerb}call Delete(rhWave) 
\end{DoxyVerb}


\subsection*{To create a new test case\+: }

The first step is to create the object that will control your test case, either a tracer or a vorticity distribution, in the \hyperlink{Tracers_8f90}{Tracers.\+f90} or \hyperlink{BVEVorticity_8f90}{B\+V\+E\+Vorticity.\+f90} files. Test cases are defined by B\+V\+E\+Setup or Tracer\+Setup objects. These objects hold the integers and real numbers that define your test case; numbers that, for example, define the amplitude of a Rossby-\/\+Haurwitz wave or the maximum value of an advected tracer. To create the object the first step is to allocate the memory to hold these parameters using the \char`\"{}\+New\char`\"{} subroutine. \begin{DoxyVerb}call New(rhWave, RHWAVE_N_INT, RHWAVE_N_REAL)
\end{DoxyVerb}


R\+H\+W\+A\+V\+E\+\_\+\+N\+\_\+\+I\+N\+I\+T and R\+H\+W\+A\+V\+E\+\_\+\+N\+\_\+\+R\+E\+A\+L are integer constants defined in the B\+V\+E\+Setup.\+f90 module; their values are 0 and 2 for the R\+H4 test case, which indicates that this test case is defined by 2 real numbers (the ampilitude and phase speeed of the wave). Now that memory is allocated to hold these parameters, the test case must be initialized from user input (typically read from a namelist file). If the variables background\+Wind\+Speed and amplitude are set by the user, the test case is defind by calling the \char`\"{}\+Init\char`\"{} subroutine on the test case object. \begin{DoxyVerb}call InitRH4Wave(rhWave, backgroundWindSpeed, amplitude)
\end{DoxyVerb}


Finally and most importantly is the subroutine which translates a test case into a tracer or vorticity distribution over a mesh. These subroutine must all have the same interface -- only 2 arguments, the first being a mesh object and second being the test case definition. This interface is required in order for the Lagrangian\+Remeshing subroutines to work properly. \begin{DoxyVerb}call SetRH4WaveOnMesh( aMesh, rhWave)
\end{DoxyVerb}


Set\+R\+H4\+Wave\+On\+Mesh calls the mathematical functions that define the vorticity distribution of a Rossby-\/\+Haurwitz wave, given the parameters defined by the rh\+Wave test case object.

To create a new test case then, users must first decide how many integers and reals are required to define their test case, and allocate the appropriate amount of memory with the \char`\"{}\+New\char`\"{} subroutine. Then the test case object must be initialized with an \char`\"{}\+Init\char`\"{} subroutine to define the parameters in the test case object's memory. Finally, users must write a Set\+Test\+Case\+On\+Mesh subroutine and the associated mathematical functions that define their test case.

\section*{Requirements }

The code requires a modern Fortran compiler with an Open\+M\+P\+I (\href{http://www.open-mpi.org}{\tt http\+://www.\+open-\/mpi.\+org}) distribution for parallel computing. Without Open\+M\+P\+I serial computations are still possible, but the code is designed to use distributed memory parallelism.

Currently the software is written for Intel compilers and makes use of the Intel M\+K\+L software library (L\+A\+P\+A\+C\+K, specifically). It is possible to use other compilers (e.\+g. gfortran) provided Open\+M\+P\+I and L\+A\+P\+A\+C\+K are also available.

L\+P\+P\+M uses interpolation software provided by A\+C\+M T\+O\+M\+S algorithm 526 written by Hiroshi Akima and implemented by John Burkhardt (\href{https://orion.math.iastate.edu/burkardt/f_src/bivar/bivar.html}{\tt https\+://orion.\+math.\+iastate.\+edu/burkardt/f\+\_\+src/bivar/bivar.\+html}), and A\+C\+M T\+O\+M\+S algorithms 772 and 773 written by Robert Renka. All other code is original and authored by Peter Bosler. \begin{DoxyVerb}H. Akima, 1978, A method of bivariate interpolation and smooth surface fitting for irregularly distributed data points.
    ACM TOMS, 4:148-159.
H. Akima, 1984, On estimating partial derivatives for bivariate interpolation of scattered data.
    Rocky Mountain Journal of Mathematics, 14:41-52.
R. Renka, 1997, Algorithm 772 : STRIPACK : Delaunay triangulation and Voronoi diagram on the surface of a sphere.
    ACM TOMS, 23:416-434.
R. Renka, 1997, Algorithm 773 : SSRFPACK : Interpolation of scattered data on the surface of a sphere with a surface under thension.
    ACM TOMS, 23:435-442.
\end{DoxyVerb}


\section*{Plotting and graphics }

L\+P\+P\+M includes subroutines for outputting data into formats readable by the V\+T\+K C++ graphics library and Para\+View, available from www.\+kitware.\+org, as well as routines for the N\+C\+A\+R Command Language (N\+C\+L) \href{http://www.ncl.ucar.edu}{\tt http\+://www.\+ncl.\+ucar.\+edu} and Matlab. 